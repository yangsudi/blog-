# What's HTTP

超文本传输协议 是一个用于传输超媒体文档的`应用层`协议。他是为Web浏览器与Web服务器之间的通信而设计的，但也可以用于其它目的。

HTTP遵循经典的`客服端-服务端模型`,客户端打开一个链接已发出请求，然后等待它受到服务器端响应。

HTTP是无状态协议，这意味着服务器不会再两个请求之间保留任务数据(状态).

该协议通常机遇TCP/IP层，但可以在任何可靠的`传输层`上使用。

## HTTP概述
HTTP是一种能够获取如 HTML 这样的网络资源的 protocol(通讯协议)。它是在 Web 上进行数据交换的基础，是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。一个完整的Web文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。

客户端和服务端通过交换各自的消息（与数据正好相反）进行交互。
由像浏览器这样的客户端发出的消息叫做`requests`,被服务端响应的消息叫做`response`.

HTTP被设计与20世纪90年代初期，是一种可扩展的协议。
他是应用层的协议，通过TCP，或者TLS-加密的TCP连接发送，理论上任何可靠的传输协议都可以使用。
因为其良好的扩展性，时至今日，它不仅被用来传输超文本，还可以用来传输图片、视频或者向服务器发送如HTML表单这样的信息。
HTTP还可以根据网页需求，仅获取部分文档内容更新网页。

### 客户端：user-agent
user-agent 就是任何能够为用户发起行为的工具。这个角色通常都是由浏览器来扮演。一些例外情况，比如是工程师使用的程序，以及Web开发人员调试应用程序。

浏览器总是作为发起一个请求的实体，他永远不是服务器（虽然近几年已经出现一些机制能够模拟由服务器发起的请求消息了）。

要展现一个网页，浏览器首先发送一个请求来获取页面的HTML文档，再解析文档中的资源信息发送其他请求，获取可执行脚本或CSS样式来进行页面布局渲染，以及一些其它页面资源（如图片和视频等）。然后，浏览器将这些资源整合到一起，展现出一个完整的文档，也就是网页。浏览器执行的脚本可以在之后的阶段获取更多资源，并相应地更新网页。

一个网页就是一个超文本文档。也就是说，有一部分显示的文本可能是链接，启动它（通常是鼠标的点击）就可以获取一个新的网页，使得用户可以控制客户端进行网上冲浪。浏览器来负责发送HTTP请求，并进一步解析HTTP返回的消息，以向用户提供明确的响应。

### Web服务端
在上述通信过程的另一端，是由Web Server来服务并提供客户端所请求的文档。Server只是虚拟意义上代表一个机器：它可以是共享负载（负载均衡）的一组服务器组成的计算机集群，也可以是一种复杂的软件，通过向其他计算机（如缓存，数据库服务器，电子商务服务器 ...）发起请求来获取部分或全部资源。

Server 不一定是一台机器，但一个机器上可以装载的众多Servers。在HTTP/1.1 和Host头部中，它们甚至可以共享同一个IP地址。

### 代理（Proxies）
在浏览器和服务器之间，有许多计算机和其他设备转发了HTTP消息。由于Web栈层次结构的原因，它们大多都出现在传输层、网络层和物理层上，对于HTTP应用层而言就是透明的，虽然它们可能会对应用层性能有重要影响。还有一部分是表现在应用层上的，被称为代理（Proxies）。代理（Proxies）既可以表现得透明，又可以不透明（“改变请求”会通过它们）

代理的主要中作：

- 缓存（可以是公开的也可以是私有的，像浏览器的缓存)
- 过滤 （像反病毒扫描，家长控制）
- 负载均衡 （让多个服务器服务不同的请求）
- 认证 （对不同资源进行权限管理）
- 日志记录 （允许存储历史信息）

## HTTP 的基本性质
### HTTP 是简单的
虽然下一代HTTP/2协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读。HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好

### HTTP 是可扩展的
在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。

### HTTP是无状态，有回话的
HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。

注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。

### HTTP 和连接
一个连接时由传输层来控制的，这从根本上不属于HTTP的范围。
HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最长的传输层协议：
TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传到，但连接并不是必须的。

在客户端（通常只浏览器）与服务器能够交互（客户端发起请求，服务器返回响应）之前，必须在这两者间建立一个TCP链接，打开一个TCP连接需要多次往返交换信息（因此耗时）。
HTTP/1.0 默认为每一对HTTP请求/响应都应打开一个单独的TCP连接。当需要连续发起多个请求时，这种模式比多个请求共享同一个TCP链接更低效。
 

## HTTP 缓存
重用已获取的资源能够有效的提升网站与应用的性能。Web缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。借助HTTP缓存，Web 站点变得更具有响应性。

## 各种类型的缓存

种类: 私有缓存与共享缓存

共享缓存存储的响应能够被多个用户使用。
私有缓存只能用于单独用户。
浏览器与代理缓存还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式。

